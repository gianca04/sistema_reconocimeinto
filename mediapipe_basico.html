<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaPipe Hands - Captura de Gestos</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .input-group label {
            font-weight: bold;
            color: #555;
        }

        input[type="text"] {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-width: 200px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .video-container {
            position: relative;
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        video, canvas {
            border: 3px solid #ddd;
            border-radius: 10px;
            max-width: 640px;
            max-height: 480px;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .status {
            text-align: center;
            margin: 20px 0;
        }

        .status p {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .frame-count {
            color: #007bff;
        }

        .gesture-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
        }

        .gesture-list {
            max-height: 300px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
        }

        .gesture-item {
            background: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .gesture-name {
            font-weight: bold;
            color: #333;
        }

        .frame-info {
            color: #666;
            font-size: 14px;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }

        .recording {
            border-color: #dc3545 !important;
            animation: recording-pulse 1s infinite;
        }

        @keyframes recording-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(220, 53, 69, 0.5); }
            50% { box-shadow: 0 0 20px rgba(220, 53, 69, 0.8); }
        }

        .export-section {
            background: #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
        }

        /* Estilos para modos */
        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .mode-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: rgba(102, 126, 234, 0.2);
            color: #667eea;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
            transform: scale(1.05);
        }

        .mode-btn:hover {
            background: rgba(102, 126, 234, 0.3);
        }

        .mode-btn.active:hover {
            background: #5a6fd8;
        }

        .mode-content {
            display: none;
        }

        .mode-content.active {
            display: block;
        }

        /* Estilos para reconocimiento */
        .recognition-results {
            background: #f8f9fa;
            border: 2px solid #28a745;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            display: none;
        }

        .recognition-results.active {
            display: block;
        }

        .result-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .recognized-gesture {
            font-size: 2.5rem;
            font-weight: bold;
            color: #28a745;
            padding: 20px;
            background: white;
            border-radius: 15px;
            min-width: 200px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .confidence-display {
            display: flex;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 400px;
        }

        .confidence-bar-container {
            flex: 1;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
        }

        .confidence-bar {
            height: 100%;
            background: linear-gradient(90deg, #dc3545, #ffc107, #28a745);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        #confidenceText {
            font-weight: bold;
            font-size: 1.2rem;
            color: #333;
            min-width: 50px;
        }

        /* Slider de tolerancia */
        input[type="range"] {
            width: 150px;
            margin: 0 10px;
        }

        #toleranceValue {
            font-weight: bold;
            color: #667eea;
            min-width: 40px;
        }

        /* Estados de reconocimiento */
        .recognizing {
            border-color: #ffc107 !important;
            animation: recognizing-pulse 1.5s infinite;
        }

        @keyframes recognizing-pulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 193, 7, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 193, 7, 0.8); }
        }

        /* Ocultar input file */
        #importFile {
            display: none;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .mode-selector {
                flex-direction: column;
                align-items: center;
            }

            .confidence-display {
                flex-direction: column;
                gap: 10px;
            }

            .recognized-gesture {
                font-size: 2rem;
                min-width: 150px;
            }
        }

        /* Estilos para secuencias y pr√°ctica */
        .sequence-status, .practice-status {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #e9ecef;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #28a745);
            border-radius: 12px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            color: #333;
            z-index: 1;
        }

        .hidden {
            display: none;
        }

        .current-frame-indicator {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .frame-progress {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .frame-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #dee2e6;
            border: 2px solid #adb5bd;
            transition: all 0.3s ease;
        }

        .frame-dot.completed {
            background: #28a745;
            border-color: #1e7e34;
        }

        .frame-dot.current {
            background: #ffc107;
            border-color: #e0a800;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .similarity-display {
            text-align: center;
        }

        .similarity-bar-container {
            width: 100%;
            height: 30px;
            background: #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            margin: 10px 0;
        }

        .similarity-bar {
            height: 100%;
            border-radius: 15px;
            transition: all 0.3s ease;
            width: 0%;
        }

        #practiceGesture {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-width: 200px;
        }

        .success-animation {
            border-color: #28a745 !important;
            animation: success-glow 1s ease-in-out;
        }

        @keyframes success-glow {
            0%, 100% { box-shadow: 0 0 10px rgba(40, 167, 69, 0.5); }
            50% { box-shadow: 0 0 25px rgba(40, 167, 69, 0.8); }
        }
    </style>
</head>
<body>
        <div class="container">
        <h1>Captura de Gestos con MediaPipe</h1>
        
        <!-- Selector de Modo -->
        <div class="mode-selector">
            <button id="captureMode" class="mode-btn active">Modo Registro</button>
            <button id="practiceMode" class="mode-btn">Modo Pr√°ctica</button>
            <button id="recognizeMode" class="mode-btn">Modo Reconocimiento</button>
        </div>
        
        <!-- Modo Captura -->
        <div id="captureModeContent" class="mode-content active">
            <div class="controls">
                <div class="input-group">
                    <label for="gestureName">Nombre del Gesto:</label>
                    <input type="text" id="gestureName" placeholder="Ej: ¬øD√≥nde vives?, Hola, Gracias">
                </div>
                <button id="startSequenceBtn" class="btn btn-primary">Iniciar Secuencia</button>
                <button id="captureBtn" class="btn btn-success" disabled>Capturar Frame <span id="frameNumber">1</span></button>
                <button id="finishSequenceBtn" class="btn btn-success" disabled>Finalizar Secuencia</button>
                <button id="clearFramesBtn" class="btn btn-danger">Limpiar Frames</button>
            </div>
            <div class="sequence-status" id="sequenceStatus">
                <p><strong>Estado:</strong> <span id="sequenceStatusText">Presiona "Iniciar Secuencia" para comenzar</span></p>
                <div class="progress-bar hidden" id="progressContainer">
                    <div class="progress-fill" id="progressFill"></div>
                    <span class="progress-text" id="progressText">0/0</span>
                </div>
            </div>
        </div>
        
        <!-- Modo Pr√°ctica -->
        <div id="practiceModeContent" class="mode-content">
            <div class="controls">
                <div class="input-group">
                    <label for="practiceGesture">Seleccionar Gesto:</label>
                    <select id="practiceGesture">
                        <option value="">-- Selecciona un gesto --</option>
                    </select>
                </div>
                <button id="startPracticeBtn" class="btn btn-primary">Iniciar Pr√°ctica</button>
                <button id="stopPracticeBtn" class="btn btn-danger" disabled>Detener Pr√°ctica</button>
                <div class="input-group">
                    <label for="similarityThreshold">Umbral de Similitud:</label>
                    <input type="range" id="similarityThreshold" min="70" max="95" step="5" value="80">
                    <span id="thresholdValue">80%</span>
                </div>
            </div>
            <div class="practice-status" id="practiceStatus">
                <div class="current-frame-indicator" id="currentFrameIndicator">
                    <h3>Frame Objetivo: <span id="targetFrameNumber">-</span></h3>
                    <div class="frame-progress" id="frameProgress"></div>
                </div>
                <div class="similarity-display" id="similarityDisplay">
                    <h4>Similitud Actual: <span id="currentSimilarity">0%</span></h4>
                    <div class="similarity-bar-container">
                        <div class="similarity-bar" id="similarityBar"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Modo Reconocimiento -->
        <div id="recognizeModeContent" class="mode-content">
            <div class="controls">
                <button id="startRecognitionBtn" class="btn btn-primary">Iniciar Reconocimiento</button>
                <button id="stopRecognitionBtn" class="btn btn-danger" disabled>Detener</button>
                <div class="input-group">
                    <label for="toleranceSlider">Tolerancia:</label>
                    <input type="range" id="toleranceSlider" min="0.1" max="0.9" step="0.1" value="0.7">
                    <span id="toleranceValue">70%</span>
                </div>
            </div>
        </div>        <div class="video-container">
            <video id="video" autoplay muted></video>
            <canvas id="outputCanvas"></canvas>
        </div>

        <div class="status">
            <p>Estado: <span id="statusText">Listo para capturar</span></p>
            <p class="frame-count">Frames capturados: <span id="frameCount">0</span></p>
        </div>

        <!-- Resultados de Reconocimiento -->
        <div id="recognitionResults" class="recognition-results">
            <h3>Resultado del Reconocimiento</h3>
            <div class="result-display">
                <div class="recognized-gesture">
                    <span id="recognizedGesture">---</span>
                </div>
                <div class="confidence-display">
                    <div class="confidence-bar-container">
                        <div class="confidence-bar" id="confidenceBar"></div>
                    </div>
                    <span id="confidenceText">0%</span>
                </div>
            </div>
        </div>

        <div class="gesture-info" id="captureInfo">
            <h3>Frames del Gesto Actual</h3>
            <div id="currentFrames">No hay frames capturados</div>
        </div>

        <div class="gesture-list" id="gestureListSection">
            <h3>Gestos Guardados</h3>
            <div id="savedGestures">No hay gestos guardados</div>
        </div>

        <div class="export-section">
            <button id="exportBtn" class="btn btn-primary">Exportar Dataset</button>
            <button id="importBtn" class="btn btn-success">Importar Dataset</button>
            <input type="file" id="importFile" accept=".json" title="Seleccionar archivo JSON para importar">
            <button id="clearAllBtn" class="btn btn-danger">Limpiar Todo</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script>
        class GestureCaptureSystem {
            constructor() {
                this.currentFrames = [];
                this.savedGestures = this.loadSavedGestures();
                this.isCapturing = false;
                this.isRecognizing = false;
                this.isPracticing = false;
                this.hands = null;
                this.camera = null;
                this.lastResults = null;
                this.currentMode = 'capture';
                this.recognitionTolerance = 0.7;
                this.recognitionBuffer = [];
                this.maxBufferSize = 10;
                
                // Nuevas propiedades para secuencias
                this.isRecordingSequence = false;
                this.currentFrameIndex = 0;
                this.maxFramesPerGesture = 10; // M√°ximo de frames por gesto
                
                // Propiedades para pr√°ctica
                this.practiceGesture = null;
                this.practiceFrameIndex = 0;
                this.similarityThreshold = 80; // Porcentaje
                this.practiceBuffer = [];
                this.lastSimilarityCheck = 0;
                
                this.initializeElements();
                this.initializeMediaPipe();
                this.initializeEventListeners();
                this.updateDisplay();
                this.switchMode('capture');
            }

            initializeElements() {
                this.videoElement = document.getElementById('video');
                this.canvasElement = document.getElementById('outputCanvas');
                this.canvasCtx = this.canvasElement.getContext('2d');
                this.gestureNameInput = document.getElementById('gestureName');
                this.statusText = document.getElementById('statusText');
                this.frameCountSpan = document.getElementById('frameCount');
            }

            async initializeMediaPipe() {
                this.hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                });

                this.hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.7,
                    minTrackingConfidence: 0.5
                });

                this.hands.onResults((results) => this.onResults(results));

                // Inicializar c√°mara
                this.camera = new Camera(this.videoElement, {
                    onFrame: async () => {
                        await this.hands.send({ image: this.videoElement });
                    },
                    width: 640,
                    height: 480
                });

                // Configurar canvas
                this.canvasElement.width = 640;
                this.canvasElement.height = 480;

                this.camera.start();
                this.statusText.textContent = "C√°mara iniciada - Listo para capturar";
            }

            onResults(results) {
                this.lastResults = results;
                
                // Limpiar canvas
                this.canvasCtx.clearRect(0, 0, this.canvasElement.width, this.canvasElement.height);
                
                // Dibujar imagen de video
                this.canvasCtx.drawImage(results.image, 0, 0, this.canvasElement.width, this.canvasElement.height);

                // Dibujar landmarks si se detectan manos
                if (results.multiHandLandmarks) {
                    for (const landmarks of results.multiHandLandmarks) {
                        drawConnectors(this.canvasCtx, landmarks, HAND_CONNECTIONS, 
                            { color: '#00FF00', lineWidth: 2 });
                        drawLandmarks(this.canvasCtx, landmarks, 
                            { color: '#FF0000', lineWidth: 1, radius: 3 });
                    }

                    // Procesar reconocimiento si est√° activo
                    if (this.isRecognizing) {
                        this.processRecognition(results);
                    }
                    
                    // Procesar pr√°ctica si est√° activa
                    if (this.isPracticing) {
                        this.processPractice(results);
                    }
                }
            }

            initializeEventListeners() {
                // Eventos de modo
                document.getElementById('captureMode').addEventListener('click', () => this.switchMode('capture'));
                document.getElementById('practiceMode').addEventListener('click', () => this.switchMode('practice'));
                document.getElementById('recognizeMode').addEventListener('click', () => this.switchMode('recognize'));

                // Eventos de captura secuencial
                document.getElementById('startSequenceBtn').addEventListener('click', () => this.startSequence());
                document.getElementById('captureBtn').addEventListener('click', () => this.captureFrame());
                document.getElementById('finishSequenceBtn').addEventListener('click', () => this.finishSequence());
                document.getElementById('clearFramesBtn').addEventListener('click', () => this.clearCurrentFrames());
                
                // Eventos de pr√°ctica
                document.getElementById('startPracticeBtn').addEventListener('click', () => this.startPractice());
                document.getElementById('stopPracticeBtn').addEventListener('click', () => this.stopPractice());
                document.getElementById('similarityThreshold').addEventListener('input', (e) => this.updateSimilarityThreshold(e));
                
                // Eventos de reconocimiento
                document.getElementById('startRecognitionBtn').addEventListener('click', () => this.startRecognition());
                document.getElementById('stopRecognitionBtn').addEventListener('click', () => this.stopRecognition());
                document.getElementById('toleranceSlider').addEventListener('input', (e) => this.updateTolerance(e));

                // Eventos de exportaci√≥n
                document.getElementById('exportBtn').addEventListener('click', () => this.exportDataset());
                document.getElementById('importBtn').addEventListener('click', () => document.getElementById('importFile').click());
                document.getElementById('importFile').addEventListener('change', (e) => this.importDataset(e));
                document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAllGestures());
            }

            // === FUNCIONES DE REGISTRO SECUENCIAL ===
            startSequence() {
                const gestureName = this.gestureNameInput.value.trim();
                if (!gestureName) {
                    alert('Por favor ingresa un nombre para el gesto.');
                    return;
                }

                this.isRecordingSequence = true;
                this.currentFrameIndex = 0;
                this.currentFrames = [];
                
                // Actualizar UI
                document.getElementById('startSequenceBtn').disabled = true;
                document.getElementById('captureBtn').disabled = false;
                document.getElementById('finishSequenceBtn').disabled = false;
                document.getElementById('gestureName').disabled = true;
                
                // Mostrar barra de progreso
                const progressContainer = document.getElementById('progressContainer');
                progressContainer.classList.remove('hidden');
                
                this.updateSequenceStatus();
                this.statusText.textContent = `Secuencia iniciada para "${gestureName}" - Captura Frame 1`;
            }

            captureFrame() {
                if (!this.lastResults || !this.lastResults.multiHandLandmarks) {
                    alert('No se detectan manos. Aseg√∫rate de que tu mano est√© visible.');
                    return;
                }

                if (!this.isRecordingSequence) {
                    alert('Primero debes iniciar una secuencia.');
                    return;
                }

                const gestureName = this.gestureNameInput.value.trim();

                // Capturar frame actual
                const frame = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    landmarks: this.lastResults.multiHandLandmarks,
                    handedness: this.lastResults.multiHandedness || [],
                    gestureName: gestureName,
                    frameIndex: this.currentFrameIndex
                };

                this.currentFrames.push(frame);
                this.currentFrameIndex++;

                // Feedback visual
                this.canvasElement.classList.add('recording');
                setTimeout(() => {
                    this.canvasElement.classList.remove('recording');
                }, 300);

                this.updateSequenceStatus();
                
                if (this.currentFrameIndex >= this.maxFramesPerGesture) {
                    this.statusText.textContent = `Frame ${this.currentFrameIndex} capturado - Secuencia completa, presiona "Finalizar"`;
                    document.getElementById('captureBtn').disabled = true;
                } else {
                    this.statusText.textContent = `Frame ${this.currentFrameIndex} capturado - Listo para Frame ${this.currentFrameIndex + 1}`;
                }
            }

            finishSequence() {
                if (this.currentFrames.length === 0) {
                    alert('No hay frames para guardar.');
                    return;
                }

                const gestureName = this.gestureNameInput.value.trim();

                // Crear objeto del gesto
                const gesture = {
                    id: Date.now(),
                    name: gestureName,
                    frames: [...this.currentFrames],
                    frameCount: this.currentFrames.length,
                    createdAt: new Date().toISOString(),
                    isSequential: true
                };

                // Guardar en array de gestos
                this.savedGestures.push(gesture);
                this.saveSavedGestures();

                // Resetear estado
                this.resetSequenceState();
                
                this.updateDisplay();
                this.updatePracticeGestureList();
                this.statusText.textContent = `‚úÖ Gesto "${gestureName}" guardado con ${gesture.frameCount} frames secuenciales`;
            }

            resetSequenceState() {
                this.isRecordingSequence = false;
                this.currentFrameIndex = 0;
                this.currentFrames = [];
                this.gestureNameInput.value = '';
                this.gestureNameInput.disabled = false;
                
                // Resetear botones
                document.getElementById('startSequenceBtn').disabled = false;
                document.getElementById('captureBtn').disabled = true;
                document.getElementById('finishSequenceBtn').disabled = true;
                
                // Ocultar barra de progreso
                document.getElementById('progressContainer').classList.add('hidden');
                
                document.getElementById('sequenceStatusText').textContent = 'Presiona "Iniciar Secuencia" para comenzar';
            }

            updateSequenceStatus() {
                const statusText = document.getElementById('sequenceStatusText');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                if (this.isRecordingSequence) {
                    statusText.textContent = `Capturando secuencia - Frame ${this.currentFrameIndex + 1} de ${this.maxFramesPerGesture}`;
                    
                    const progress = (this.currentFrames.length / this.maxFramesPerGesture) * 100;
                    progressFill.style.width = progress + '%';
                    progressText.textContent = `${this.currentFrames.length}/${this.maxFramesPerGesture}`;
                    
                    // Actualizar n√∫mero de frame en el bot√≥n
                    document.getElementById('frameNumber').textContent = this.currentFrameIndex + 1;
                }
            }

            // === FUNCIONES DE PR√ÅCTICA SECUENCIAL ===
            startPractice() {
                const selectedGestureId = document.getElementById('practiceGesture').value;
                if (!selectedGestureId) {
                    alert('Por favor selecciona un gesto para practicar.');
                    return;
                }

                this.practiceGesture = this.savedGestures.find(g => g.id == selectedGestureId);
                if (!this.practiceGesture) {
                    alert('Gesto no encontrado.');
                    return;
                }

                this.isPracticing = true;
                this.practiceFrameIndex = 0;
                this.practiceBuffer = [];
                
                // Actualizar UI
                document.getElementById('startPracticeBtn').disabled = true;
                document.getElementById('stopPracticeBtn').disabled = false;
                document.getElementById('practiceGesture').disabled = true;
                
                this.canvasElement.classList.add('recognizing');
                this.updatePracticeDisplay();
                
                this.statusText.textContent = `Pr√°ctica iniciada: "${this.practiceGesture.name}" - Realiza Frame 1`;
            }

            stopPractice() {
                this.isPracticing = false;
                this.practiceGesture = null;
                this.practiceFrameIndex = 0;
                this.practiceBuffer = [];
                
                // Actualizar UI
                document.getElementById('startPracticeBtn').disabled = false;
                document.getElementById('stopPracticeBtn').disabled = true;
                document.getElementById('practiceGesture').disabled = false;
                
                this.canvasElement.classList.remove('recognizing', 'success-animation');
                
                // Limpiar display
                document.getElementById('targetFrameNumber').textContent = '-';
                document.getElementById('currentSimilarity').textContent = '0%';
                document.getElementById('similarityBar').style.width = '0%';
                document.getElementById('frameProgress').innerHTML = '';
                
                this.statusText.textContent = 'Pr√°ctica detenida';
            }

            updateSimilarityThreshold(event) {
                this.similarityThreshold = parseInt(event.target.value);
                document.getElementById('thresholdValue').textContent = this.similarityThreshold + '%';
            }

            processPractice(results) {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    document.getElementById('currentSimilarity').textContent = '0%';
                    document.getElementById('similarityBar').style.width = '0%';
                    return;
                }

                if (!this.practiceGesture || this.practiceFrameIndex >= this.practiceGesture.frames.length) {
                    return;
                }

                // Limitar la frecuencia de verificaci√≥n para evitar sobrecarga
                const now = Date.now();
                if (now - this.lastSimilarityCheck < 100) return; // Verificar cada 100ms
                this.lastSimilarityCheck = now;

                const currentFrame = {
                    landmarks: results.multiHandLandmarks,
                    handedness: results.multiHandedness || []
                };

                const targetFrame = this.practiceGesture.frames[this.practiceFrameIndex];
                const similarity = this.calculateFrameSimilarity(currentFrame, targetFrame) * 100;

                this.updateSimilarityDisplay(similarity);

                // Verificar si la similitud es suficiente para avanzar
                if (similarity >= this.similarityThreshold) {
                    this.advancePracticeFrame();
                }
            }

            advancePracticeFrame() {
                this.practiceFrameIndex++;
                
                // Feedback visual de √©xito
                this.canvasElement.classList.add('success-animation');
                setTimeout(() => {
                    this.canvasElement.classList.remove('success-animation');
                }, 1000);

                if (this.practiceFrameIndex >= this.practiceGesture.frames.length) {
                    // ¬°Pr√°ctica completada!
                    this.completePractice();
                } else {
                    // Continuar con el siguiente frame
                    this.updatePracticeDisplay();
                    this.statusText.textContent = `Frame ${this.practiceFrameIndex} completado - Realiza Frame ${this.practiceFrameIndex + 1}`;
                }
            }

            completePractice() {
                this.statusText.textContent = `¬°Excelente! Pr√°ctica completada para "${this.practiceGesture.name}"`;
                
                // Mostrar animaci√≥n de √©xito prolongada
                this.canvasElement.classList.add('success-animation');
                
                setTimeout(() => {
                    this.stopPractice();
                }, 3000);
            }

            updatePracticeDisplay() {
                if (!this.practiceGesture) return;

                const targetFrameNum = this.practiceFrameIndex + 1;
                const totalFrames = this.practiceGesture.frames.length;
                
                document.getElementById('targetFrameNumber').textContent = `${targetFrameNum} de ${totalFrames}`;
                
                // Crear indicadores de progreso visual
                const frameProgress = document.getElementById('frameProgress');
                frameProgress.innerHTML = '';
                
                for (let i = 0; i < totalFrames; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'frame-dot';
                    
                    if (i < this.practiceFrameIndex) {
                        dot.classList.add('completed');
                    } else if (i === this.practiceFrameIndex) {
                        dot.classList.add('current');
                    }
                    
                    frameProgress.appendChild(dot);
                }
            }

            updateSimilarityDisplay(similarity) {
                document.getElementById('currentSimilarity').textContent = Math.round(similarity) + '%';
                
                const similarityBar = document.getElementById('similarityBar');
                similarityBar.style.width = similarity + '%';
                
                // Cambiar color seg√∫n similitud
                if (similarity >= this.similarityThreshold) {
                    similarityBar.style.background = '#28a745';
                } else if (similarity >= 60) {
                    similarityBar.style.background = '#ffc107';
                } else {
                    similarityBar.style.background = '#dc3545';
                }
            }

            updatePracticeGestureList() {
                const select = document.getElementById('practiceGesture');
                select.innerHTML = '<option value="">-- Selecciona un gesto --</option>';
                
                this.savedGestures.forEach(gesture => {
                    const option = document.createElement('option');
                    option.value = gesture.id;
                    option.textContent = `${gesture.name} (${gesture.frameCount} frames)`;
                    select.appendChild(option);
                });
            }

            captureFrame() {
                if (!this.lastResults || !this.lastResults.multiHandLandmarks) {
                    alert('No se detectan manos. Aseg√∫rate de que tu mano est√© visible.');
                    return;
                }

                if (!this.isRecordingSequence) {
                    alert('Primero debes iniciar una secuencia.');
                    return;
                }

                const gestureName = this.gestureNameInput.value.trim();

                // Capturar frame actual
                const frame = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    landmarks: this.lastResults.multiHandLandmarks,
                    handedness: this.lastResults.multiHandedness || [],
                    gestureName: gestureName,
                    frameIndex: this.currentFrameIndex
                };

                this.currentFrames.push(frame);
                this.currentFrameIndex++;

                // Feedback visual
                this.canvasElement.classList.add('recording');
                setTimeout(() => {
                    this.canvasElement.classList.remove('recording');
                }, 300);

                this.updateSequenceStatus();
                
                if (this.currentFrameIndex >= this.maxFramesPerGesture) {
                    this.statusText.textContent = `Frame ${this.currentFrameIndex} capturado - Secuencia completa, presiona "Finalizar"`;
                    document.getElementById('captureBtn').disabled = true;
                } else {
                    this.statusText.textContent = `Frame ${this.currentFrameIndex} capturado - Listo para Frame ${this.currentFrameIndex + 1}`;
                }
            }

            clearCurrentFrames() {
                this.resetSequenceState();
                this.updateDisplay();
                this.statusText.textContent = "Frames limpiados";
            }

            deleteGesture(gestureId) {
                this.savedGestures = this.savedGestures.filter(g => g.id !== gestureId);
                this.saveSavedGestures();
                this.updateDisplay();
                this.updatePracticeGestureList();
                this.statusText.textContent = "Gesto eliminado";
            }

            clearAllGestures() {
                if (confirm('¬øEst√°s seguro de que quieres eliminar todos los gestos?')) {
                    this.savedGestures = [];
                    this.currentFrames = [];
                    this.resetSequenceState();
                    this.saveSavedGestures();
                    this.updateDisplay();
                    this.updatePracticeGestureList();
                    this.statusText.textContent = "Todos los gestos eliminados";
                }
            }

            // === FUNCIONES DE MODO ===
            switchMode(mode) {
                this.currentMode = mode;
                
                // Detener cualquier proceso activo
                this.stopRecognition();
                this.stopPractice();
                this.resetSequenceState();
                
                // Actualizar botones de modo
                document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.mode-content').forEach(content => content.classList.remove('active'));
                
                // Activar modo seleccionado
                document.getElementById(mode + 'Mode').classList.add('active');
                document.getElementById(mode + 'ModeContent').classList.add('active');
                
                // Mostrar/ocultar elementos seg√∫n el modo
                if (mode === 'capture') {
                    document.getElementById('captureInfo').style.display = 'block';
                    document.getElementById('gestureListSection').style.display = 'block';
                    document.getElementById('recognitionResults').classList.remove('active');
                    this.statusText.textContent = "Modo registro activado - Captura gestos secuenciales";
                } else if (mode === 'practice') {
                    document.getElementById('captureInfo').style.display = 'none';
                    document.getElementById('gestureListSection').style.display = 'none';
                    document.getElementById('recognitionResults').classList.remove('active');
                    this.updatePracticeGestureList();
                    
                    if (this.savedGestures.length === 0) {
                        this.statusText.textContent = "No hay gestos guardados para practicar";
                    } else {
                        this.statusText.textContent = "Modo pr√°ctica activado - Selecciona un gesto para practicar";
                    }
                } else if (mode === 'recognize') {
                    document.getElementById('captureInfo').style.display = 'none';
                    document.getElementById('gestureListSection').style.display = 'none';
                    document.getElementById('recognitionResults').classList.add('active');
                    this.statusText.textContent = "Modo reconocimiento activado";
                    
                    if (this.savedGestures.length === 0) {
                        this.statusText.textContent = "No hay gestos guardados para reconocer";
                    }
                }
            }

            // === FUNCIONES DE RECONOCIMIENTO ===
            startRecognition() {
                if (this.savedGestures.length === 0) {
                    alert('No hay gestos guardados para reconocer. Cambia al modo captura y graba algunos gestos primero.');
                    return;
                }

                this.isRecognizing = true;
                this.recognitionBuffer = [];
                
                // Actualizar UI
                this.canvasElement.classList.add('recognizing');
                document.getElementById('startRecognitionBtn').disabled = true;
                document.getElementById('stopRecognitionBtn').disabled = false;
                this.statusText.textContent = "Reconociendo gestos... Realiza un gesto";
                
                // Limpiar resultados anteriores
                this.updateRecognitionDisplay('---', 0);
            }

            stopRecognition() {
                this.isRecognizing = false;
                this.recognitionBuffer = [];
                
                // Actualizar UI
                this.canvasElement.classList.remove('recognizing');
                document.getElementById('startRecognitionBtn').disabled = false;
                document.getElementById('stopRecognitionBtn').disabled = true;
                this.statusText.textContent = "Reconocimiento detenido";
                
                // Limpiar resultados
                this.updateRecognitionDisplay('---', 0);
            }

            updateTolerance(event) {
                this.recognitionTolerance = parseFloat(event.target.value);
                document.getElementById('toleranceValue').textContent = Math.round(this.recognitionTolerance * 100) + '%';
            }

            processRecognition(results) {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    return;
                }

                // Crear frame actual para comparaci√≥n
                const currentFrame = {
                    landmarks: results.multiHandLandmarks,
                    handedness: results.multiHandedness || [],
                    timestamp: Date.now()
                };

                // Agregar al buffer de reconocimiento
                this.recognitionBuffer.push(currentFrame);
                if (this.recognitionBuffer.length > this.maxBufferSize) {
                    this.recognitionBuffer.shift();
                }

                // Procesar reconocimiento solo si tenemos suficientes frames
                if (this.recognitionBuffer.length >= 3) {
                    this.performGestureRecognition(currentFrame);
                }
            }

            performGestureRecognition(currentFrame) {
                let bestMatch = null;
                let bestScore = 0;

                // Comparar con todos los gestos guardados
                for (const gesture of this.savedGestures) {
                    const score = this.compareWithGesture(currentFrame, gesture);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = gesture;
                    }
                }

                // Aplicar tolerancia
                if (bestMatch && bestScore >= this.recognitionTolerance) {
                    this.updateRecognitionDisplay(bestMatch.name, bestScore * 100);
                } else {
                    this.updateRecognitionDisplay('No reconocido', bestScore * 100);
                }
            }

            compareWithGesture(currentFrame, gesture) {
                let maxSimilarity = 0;

                // Comparar con cada frame del gesto guardado
                for (const storedFrame of gesture.frames) {
                    const similarity = this.calculateFrameSimilarity(currentFrame, storedFrame);
                    maxSimilarity = Math.max(maxSimilarity, similarity);
                }

                return maxSimilarity;
            }

            calculateFrameSimilarity(frame1, frame2) {
                if (!frame1.landmarks || !frame2.landmarks || 
                    frame1.landmarks.length === 0 || frame2.landmarks.length === 0) {
                    return 0;
                }

                const landmarks1 = frame1.landmarks[0]; // Primera mano
                const landmarks2 = frame2.landmarks[0]; // Primera mano

                if (!landmarks1 || !landmarks2 || landmarks1.length !== landmarks2.length) {
                    return 0;
                }

                // Calcular distancia euclidiana normalizada
                let totalDistance = 0;
                let validPoints = 0;

                for (let i = 0; i < landmarks1.length; i++) {
                    const p1 = landmarks1[i];
                    const p2 = landmarks2[i];

                    if (p1 && p2) {
                        const distance = Math.sqrt(
                            Math.pow(p1.x - p2.x, 2) + 
                            Math.pow(p1.y - p2.y, 2) + 
                            Math.pow((p1.z || 0) - (p2.z || 0), 2)
                        );
                        totalDistance += distance;
                        validPoints++;
                    }
                }

                if (validPoints === 0) return 0;

                // Convertir distancia a similitud (0-1)
                const avgDistance = totalDistance / validPoints;
                const similarity = Math.max(0, 1 - (avgDistance * 3)); // Factor de escala ajustable

                return similarity;
            }

            updateRecognitionDisplay(gestureName, confidence) {
                document.getElementById('recognizedGesture').textContent = gestureName;
                document.getElementById('confidenceText').textContent = Math.round(confidence) + '%';
                
                // Actualizar barra de confianza
                const confidenceBar = document.getElementById('confidenceBar');
                confidenceBar.style.width = confidence + '%';
                
                // Cambiar color seg√∫n confianza
                if (confidence >= 70) {
                    confidenceBar.style.background = '#28a745';
                } else if (confidence >= 50) {
                    confidenceBar.style.background = '#ffc107';
                } else {
                    confidenceBar.style.background = '#dc3545';
                }
            }

            updateDisplay() {
                // Actualizar contador de frames
                this.frameCountSpan.textContent = this.currentFrames.length;
                
                // Habilitar/deshabilitar bot√≥n de finalizar secuencia
                if (document.getElementById('finishSequenceBtn')) {
                    document.getElementById('finishSequenceBtn').disabled = 
                        this.currentFrames.length === 0 || !this.isRecordingSequence;
                }

                // Actualizar lista de frames actuales
                const currentFramesDiv = document.getElementById('currentFrames');
                if (this.currentFrames.length === 0) {
                    currentFramesDiv.innerHTML = 'No hay frames capturados';
                } else {
                    currentFramesDiv.innerHTML = this.currentFrames.map((frame, index) => 
                        `<div class="gesture-item">
                            <span>Frame ${index + 1}</span>
                            <span class="frame-info">${new Date(frame.timestamp).toLocaleTimeString()}</span>
                        </div>`
                    ).join('');
                }

                // Actualizar lista de gestos guardados
                const savedGesturesDiv = document.getElementById('savedGestures');
                if (this.savedGestures.length === 0) {
                    savedGesturesDiv.innerHTML = 'No hay gestos guardados';
                } else {
                    savedGesturesDiv.innerHTML = this.savedGestures.map(gesture => 
                        `<div class="gesture-item">
                            <div>
                                <span class="gesture-name">${gesture.name}</span>
                                <div class="frame-info">
                                    ${gesture.frameCount} frames${gesture.isSequential ? ' (secuencial)' : ''} - 
                                    ${new Date(gesture.createdAt).toLocaleDateString()}
                                </div>
                            </div>
                            <button class="delete-btn" onclick="gestureSystem.deleteGesture(${gesture.id})">Eliminar</button>
                        </div>`
                    ).join('');
                }
            }

            exportDataset() {
                if (this.savedGestures.length === 0) {
                    alert('No hay gestos para exportar.');
                    return;
                }

                const dataset = {
                    version: "1.0",
                    createdAt: new Date().toISOString(),
                    totalGestures: this.savedGestures.length,
                    totalFrames: this.savedGestures.reduce((sum, g) => sum + g.frameCount, 0),
                    gestures: this.savedGestures
                };

                const blob = new Blob([JSON.stringify(dataset, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `gestos_dataset_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);

                this.statusText.textContent = "Dataset exportado";
            }

            importDataset(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Validar estructura del dataset
                        if (data.gestures && Array.isArray(data.gestures)) {
                            // Preguntar si quiere reemplazar o agregar
                            const replace = confirm('¬øQuieres reemplazar los gestos actuales? (Cancelar para agregar al dataset existente)');
                            
                            if (replace) {
                                this.savedGestures = data.gestures;
                            } else {
                                // Agregar gestos nuevos, evitando duplicados por nombre
                                data.gestures.forEach(newGesture => {
                                    const existingIndex = this.savedGestures.findIndex(g => g.name === newGesture.name);
                                    if (existingIndex !== -1) {
                                        // Reemplazar gesto existente
                                        this.savedGestures[existingIndex] = newGesture;
                                    } else {
                                        // Agregar nuevo gesto
                                        this.savedGestures.push(newGesture);
                                    }
                                });
                            }
                            
                            this.saveSavedGestures();
                            this.updateDisplay();
                            this.statusText.textContent = `Dataset importado: ${data.gestures.length} gestos cargados`;
                        } else {
                            alert('Formato de archivo inv√°lido. El archivo debe contener un dataset de gestos v√°lido.');
                        }
                    } catch (error) {
                        alert('Error al leer el archivo. Aseg√∫rate de que sea un archivo JSON v√°lido.');
                        console.error('Error importing dataset:', error);
                    }
                };
                reader.readAsText(file);
                
                // Limpiar input para permitir importar el mismo archivo nuevamente
                event.target.value = '';
            }

            loadSavedGestures() {
                const saved = localStorage.getItem('savedGestures');
                return saved ? JSON.parse(saved) : [];
            }

            saveSavedGestures() {
                localStorage.setItem('savedGestures', JSON.stringify(this.savedGestures));
            }
        }

        // Inicializar sistema
        let gestureSystem;
        document.addEventListener('DOMContentLoaded', () => {
            gestureSystem = new GestureCaptureSystem();
        });
    </script>
</body>
</html>
